-- 1. TABELA PRINCIPAL DE FATURAS
CREATE TABLE invoices (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  invoice_number TEXT NOT NULL,
  issue_date DATE NOT NULL,
  due_date DATE NOT NULL,
  payment_due_date DATE,
  purchase_order TEXT,
  terms TEXT,
  currency TEXT NOT NULL DEFAULT 'MT',
  subtotal NUMERIC(12, 2) NOT NULL,
  total_tax NUMERIC(12, 2) NOT NULL,
  total_amount NUMERIC(12, 2) NOT NULL,
  status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'issued', 'paid', 'cancelled')),
  logo_url TEXT,
  signature_url TEXT,
  notes TEXT,
  user_id UUID REFERENCES auth.users NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 2. TABELA DE PAGAMENTOS (versão atualizada)
CREATE TABLE payments (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  external_id TEXT NOT NULL UNIQUE,
  method VARCHAR(20) NOT NULL CHECK (method IN ('m-pesa', 'e-mola', 'transfer', 'cash')),
  phone_number VARCHAR(20) NOT NULL,
  amount NUMERIC(10, 2) NOT NULL,
  status VARCHAR(20) NOT NULL CHECK (status IN ('pending', 'completed', 'failed', 'refunded')),
  invoice_data JSONB NOT NULL,
  metadata JSONB,
  receipt_url TEXT,
  user_id UUID REFERENCES auth.users NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  invoice_id UUID REFERENCES invoices(id)
);

-- 3. TABELA DE EMISSORES
CREATE TABLE issuers (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  company_name TEXT NOT NULL,
  document TEXT NOT NULL,
  country TEXT NOT NULL,
  city TEXT NOT NULL,
  district TEXT NOT NULL,
  contact_person TEXT,
  email TEXT NOT NULL,
  phone TEXT NOT NULL,
  user_id UUID REFERENCES auth.users NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(document, user_id)
);

-- 4. TABELA DE DESTINATÁRIOS
CREATE TABLE recipients (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  full_name TEXT NOT NULL,
  document TEXT,
  country TEXT,
  city TEXT,
  district TEXT,
  email TEXT NOT NULL,
  phone TEXT NOT NULL,
  user_id UUID REFERENCES auth.users NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 5. TABELA DE RELACIONAMENTO ENTRE FATURAS E EMISSORES/DESTINATÁRIOS (atualizada)
CREATE TABLE invoice_parties (
  invoice_id UUID REFERENCES invoices ON DELETE CASCADE,
  issuer_id UUID REFERENCES issuers,
  recipient_id UUID REFERENCES recipients,
  issuer_address TEXT,
  recipient_address TEXT,
  PRIMARY KEY (invoice_id),
  CONSTRAINT chk_parties CHECK (
    (issuer_id IS NOT NULL AND recipient_id IS NOT NULL) OR
    (issuer_id IS NOT NULL AND recipient_id IS NULL) OR
    (issuer_id IS NULL AND recipient_id IS NOT NULL)
  )
);

-- 6. TABELA DE ITENS DA FATURA
CREATE TABLE invoice_items (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  invoice_id UUID REFERENCES invoices ON DELETE CASCADE NOT NULL,
  description TEXT NOT NULL,
  quantity NUMERIC(10, 2) NOT NULL,
  unit_price NUMERIC(12, 2) NOT NULL,
  total_price NUMERIC(12, 2) NOT NULL,
  position INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 7. TABELA DE TAXAS DOS ITENS
CREATE TABLE item_taxes (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  item_id UUID REFERENCES invoice_items ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  rate NUMERIC(10, 2) NOT NULL,
  amount NUMERIC(12, 2) NOT NULL,
  tax_type TEXT NOT NULL CHECK (tax_type IN ('percent', 'fixed')),
  category TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 8. TABELA DE TAXAS CONSOLIDADAS
CREATE TABLE invoice_tax_summary (
  invoice_id UUID REFERENCES invoices ON DELETE CASCADE,
  tax_name TEXT NOT NULL,
  tax_amount NUMERIC(12, 2) NOT NULL,
  PRIMARY KEY (invoice_id, tax_name)
);

-- 9. TABELA DE HISTÓRICO DE STATUS (nova)
CREATE TABLE invoice_status_history (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  invoice_id UUID REFERENCES invoices(id) NOT NULL,
  status TEXT NOT NULL,
  changed_by UUID REFERENCES auth.users,
  notes TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 10. TABELA DE ANEXOS DE FATURA (nova)
CREATE TABLE invoice_attachments (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  invoice_id UUID REFERENCES invoices(id) NOT NULL,
  file_url TEXT NOT NULL,
  file_name TEXT NOT NULL,
  file_type TEXT NOT NULL,
  uploaded_by UUID REFERENCES auth.users NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ÍNDICES PARA MELHOR PERFORMANCE
CREATE INDEX idx_invoices_user_id ON invoices(user_id);
CREATE INDEX idx_invoices_status ON invoices(status);
CREATE INDEX idx_invoice_items_invoice_id ON invoice_items(invoice_id);
CREATE INDEX idx_item_taxes_item_id ON item_taxes(item_id);
CREATE INDEX idx_payments_invoice_id ON payments(invoice_id);
CREATE INDEX idx_payments_user_id ON payments(user_id);
CREATE INDEX idx_payments_status ON payments(status);
CREATE INDEX idx_invoice_status_history_invoice_id ON invoice_status_history(invoice_id);
CREATE INDEX idx_invoice_attachments_invoice_id ON invoice_attachments(invoice_id);

-- FUNÇÕES E TRIGGERS
-- Função para atualizar timestamp
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para atualizar invoices
CREATE TRIGGER update_invoices_modtime
BEFORE UPDATE ON invoices
FOR EACH ROW EXECUTE FUNCTION update_modified_column();

-- Trigger para atualizar payments
CREATE TRIGGER update_payments_modtime
BEFORE UPDATE ON payments
FOR EACH ROW EXECUTE FUNCTION update_modified_column();

-- Função para validar datas da fatura
CREATE OR REPLACE FUNCTION validate_invoice_dates()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.due_date < NEW.issue_date THEN
    RAISE EXCEPTION 'Due date cannot be before issue date';
  END IF;
  
  IF NEW.payment_due_date IS NOT NULL AND NEW.payment_due_date < NEW.issue_date THEN
    RAISE EXCEPTION 'Payment due date cannot be before issue date';
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para validar datas
CREATE TRIGGER check_invoice_dates
BEFORE INSERT OR UPDATE ON invoices
FOR EACH ROW EXECUTE FUNCTION validate_invoice_dates();

-- Função para validar faturas pagas
CREATE OR REPLACE FUNCTION validate_paid_invoice()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.status = 'paid' AND NOT EXISTS (
    SELECT 1 FROM payments 
    WHERE invoice_id = NEW.id AND status = 'completed'
  ) THEN
    RAISE EXCEPTION 'Invoice cannot be marked as paid without a completed payment';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para validar faturas pagas
CREATE TRIGGER trg_validate_paid_invoice
BEFORE INSERT OR UPDATE OF status ON invoices
FOR EACH ROW EXECUTE FUNCTION validate_paid_invoice();

-- VIEWS PARA RELATÓRIOS
-- View para faturas com pagamentos
CREATE OR REPLACE VIEW invoice_with_payments AS
SELECT 
  i.*,
  p.id as payment_id,
  p.method as payment_method,
  p.status as payment_status,
  p.amount as payment_amount,
  p.created_at as payment_date,
  p.receipt_url
FROM invoices i
LEFT JOIN LATERAL (
  SELECT * FROM payments 
  WHERE invoice_id = i.id 
  ORDER BY created_at DESC 
  LIMIT 1
) p ON true;

-- View para relatório de taxas
CREATE OR REPLACE VIEW tax_report AS
SELECT 
  i.id as invoice_id,
  i.invoice_number,
  i.issue_date,
  ts.tax_name,
  ts.tax_amount,
  (ts.tax_amount / i.total_amount * 100) as tax_percentage
FROM invoices i
JOIN invoice_tax_summary ts ON ts.invoice_id = i.id;

-- View para histórico completo da fatura
CREATE OR REPLACE VIEW invoice_full_history AS
SELECT 
  i.id,
  i.invoice_number,
  i.status as current_status,
  h.status as history_status,
  h.created_at as status_change_date,
  u.email as changed_by_email,
  h.notes as status_notes
FROM invoices i
JOIN invoice_status_history h ON h.invoice_id = i.id
LEFT JOIN auth.users u ON h.changed_by = u.id
ORDER BY h.created_at DESC;

-- STORED PROCEDURES
-- Procedure para atualizar status da fatura
CREATE OR REPLACE PROCEDURE update_invoice_status(
  invoice_id UUID,
  new_status TEXT,
  user_id UUID,
  notes TEXT DEFAULT NULL
)
LANGUAGE plpgsql
AS $$
BEGIN
  -- Atualiza o status principal
  UPDATE invoices 
  SET status = new_status, updated_at = NOW()
  WHERE id = invoice_id;
  
  -- Registra no histórico
  INSERT INTO invoice_status_history (invoice_id, status, changed_by, notes)
  VALUES (invoice_id, new_status, user_id, notes);
END;
$$;

-- Procedure para processar pagamento
CREATE OR REPLACE PROCEDURE process_payment(
  p_external_id TEXT,
  p_method TEXT,
  p_phone_number TEXT,
  p_amount NUMERIC,
  p_status TEXT,
  p_invoice_id UUID,
  p_user_id UUID,
  p_metadata JSONB DEFAULT NULL,
  p_receipt_url TEXT DEFAULT NULL
)
LANGUAGE plpgsql
AS $$
BEGIN
  -- Insere o pagamento
  INSERT INTO payments (
    external_id, method, phone_number, amount, status,
    invoice_id, user_id, metadata, receipt_url, invoice_data
  )
  SELECT 
    p_external_id, p_method, p_phone_number, p_amount, p_status,
    p_invoice_id, p_user_id, p_metadata, p_receipt_url,
    to_jsonb(i.*) - 'id' - 'created_at' - 'updated_at'
  FROM invoices i
  WHERE i.id = p_invoice_id;
  
  -- Se o pagamento foi completado, atualiza o status da fatura
  IF p_status = 'completed' THEN
    CALL update_invoice_status(p_invoice_id, 'paid', p_user_id, 'Pagamento processado via ' || p_method);
  END IF;
END;
$$;

-- COMENTÁRIOS PARA DOCUMENTAÇÃO
COMMENT ON TABLE invoices IS 'Armazena as faturas principais do sistema';
COMMENT ON COLUMN invoices.payment_due_date IS 'Data limite para pagamento da fatura';
COMMENT ON COLUMN invoices.notes IS 'Observações adicionais sobre a fatura';

COMMENT ON TABLE payments IS 'Registros de pagamentos associados a faturas';
COMMENT ON COLUMN payments.external_id IS 'ID da transação no gateway de pagamento externo';
COMMENT ON COLUMN payments.metadata IS 'Dados adicionais do pagamento no formato JSON';

COMMENT ON TABLE invoice_status_history IS 'Histórico completo de alterações de status das faturas';
COMMENT ON TABLE invoice_attachments IS 'Arquivos anexados às faturas (PDFs, imagens, etc.)';
